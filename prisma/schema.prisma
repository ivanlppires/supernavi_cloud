generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Lab (tenant) for multi-tenant isolation
model Lab {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  edgeKeys EdgeKey[]

  @@map("labs")
}

/// Edge device authentication keys (one per edge agent)
model EdgeKey {
  id        String   @id @default(uuid()) @db.Uuid
  labId     String   @map("lab_id") @db.Uuid
  name      String
  keyHash   String   @map("key_hash") // SHA-256 hex of the raw key
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  lab Lab @relation(fields: [labId], references: [id], onDelete: Cascade)

  @@index([keyHash])
  @@index([labId])
  @@map("edge_keys")
}

/// Bindings between PathoWeb cases and SuperNavi slides
model CaseBinding {
  id            String   @id @default(uuid()) @db.Uuid
  labId         String   @map("lab_id") @db.Uuid
  pathowebRef   String   @map("pathoweb_ref")
  slideId       String   @map("slide_id")
  boundByUserId String?  @map("bound_by_user_id") @db.Uuid
  boundAt       DateTime @default(now()) @map("bound_at") @db.Timestamptz

  @@unique([pathowebRef, slideId])
  @@index([labId])
  @@index([pathowebRef])
  @@index([slideId])
  @@map("case_bindings")
}

/// Event store - append-only log of all events from edge
model Event {
  id            String   @id @default(uuid()) @db.Uuid
  eventId       String   @unique @map("event_id")
  edgeId        String   @map("edge_id")
  aggregateType String   @map("aggregate_type")
  aggregateId   String   @map("aggregate_id")
  type          String
  occurredAt    DateTime @map("occurred_at") @db.Timestamptz
  receivedAt    DateTime @default(now()) @map("received_at") @db.Timestamptz
  payload       Json

  @@index([edgeId])
  @@index([aggregateType, aggregateId])
  @@index([occurredAt])
  @@map("events")
}

/// Read model for cases
model CaseRead {
  caseId         String    @id @map("case_id")
  title          String
  patientRef     String    @map("patient_ref")
  patientAge     Int?      @map("patient_age")
  patientSex     String?   @map("patient_sex")
  doctor         String?
  status         String    @default("active")
  ownerId        String?   @map("owner_id") @db.Uuid
  createdAt      DateTime  @map("created_at") @db.Timestamptz
  updatedAt      DateTime  @map("updated_at") @db.Timestamptz
  lastEventId    String?   @map("last_event_id")
  lastOccurredAt DateTime? @map("last_occurred_at") @db.Timestamptz

  slides        SlideRead[]
  collaborators CaseCollaborator[]

  @@index([status])
  @@index([updatedAt])
  @@index([ownerId])
  @@map("cases_read")
}

/// Case collaborators - users invited to collaborate on a case
model CaseCollaborator {
  id        String   @id @default(uuid()) @db.Uuid
  caseId    String   @map("case_id")
  userId    String   @map("user_id") @db.Uuid
  role      String   @default("collaborator") // viewer, collaborator
  invitedBy String?  @map("invited_by") @db.Uuid
  invitedAt DateTime @default(now()) @map("invited_at") @db.Timestamptz
  status    String   @default("pending") // pending, accepted, declined

  case CaseRead @relation(fields: [caseId], references: [caseId], onDelete: Cascade)
  user User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([caseId, userId])
  @@index([userId])
  @@index([status])
  @@map("case_collaborators")
}

/// Read model for slides
model SlideRead {
  slideId            String    @id @map("slide_id")
  caseId             String?   @map("case_id")
  svsFilename        String    @map("svs_filename")
  width              Int
  height             Int
  mpp                Float
  scanner            String?
  hasPreview         Boolean   @default(false) @map("has_preview")
  externalCaseId     String?   @map("external_case_id")
  externalCaseBase   String?   @map("external_case_base")
  externalSlideLabel String?   @map("external_slide_label")
  confirmedCaseLink  Boolean   @default(true) @map("confirmed_case_link")
  edgeId             String?   @map("edge_id")
  labId              String?   @map("lab_id") @db.Uuid
  cloudStatus        String    @default("UNKNOWN") @map("cloud_status") // UPLOADED | PROCESSING | READY | FAILED | UNKNOWN
  dziUrl             String?   @map("dzi_url")
  tileCount          Int?      @map("tile_count")
  s3Prefix           String?   @map("s3_prefix")
  readyForReviewAt   DateTime? @map("ready_for_review_at") @db.Timestamptz
  updatedAt          DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  lastEventId        String?   @map("last_event_id")
  lastOccurredAt     DateTime? @map("last_occurred_at") @db.Timestamptz

  case         CaseRead?     @relation(fields: [caseId], references: [caseId], onDelete: Cascade)
  previewAsset PreviewAsset?

  @@index([caseId])
  @@index([hasPreview])
  @@index([externalCaseId])
  @@index([externalCaseBase])
  @@index([edgeId])
  @@index([svsFilename])
  @@index([labId, cloudStatus])
  @@map("slides_read")
}

/// Preview assets metadata for signed URL generation
model PreviewAsset {
  slideId         String   @id @map("slide_id")
  caseId          String?  @map("case_id")
  wasabiBucket    String   @map("wasabi_bucket")
  wasabiRegion    String   @map("wasabi_region")
  wasabiEndpoint  String   @map("wasabi_endpoint")
  wasabiPrefix    String   @map("wasabi_prefix")
  thumbKey        String   @map("thumb_key")
  manifestKey     String   @map("manifest_key")
  lowTilesPrefix  String   @map("low_tiles_prefix")
  maxPreviewLevel Int      @map("max_preview_level")
  previewWidth    Int?     @map("preview_width")
  previewHeight   Int?     @map("preview_height")
  tileSize        Int      @map("tile_size")
  format          String
  publishedAt     DateTime @default(now()) @map("published_at") @db.Timestamptz
  lastEventId     String?  @map("last_event_id")
  lastOccurredAt  DateTime? @map("last_occurred_at") @db.Timestamptz

  slide SlideRead @relation(fields: [slideId], references: [slideId], onDelete: Cascade)

  @@index([caseId])
  @@map("preview_assets")
}

/// Users for authentication
model User {
  id             String    @id @default(uuid()) @db.Uuid
  email          String    @unique
  name           String
  role           String    @default("pathologist")
  avatarUrl      String?   @map("avatar_url")
  crm            String?
  specialization String?
  googleId       String?   @unique @map("google_id")
  appleId        String?   @unique @map("apple_id")
  passwordHash   String?   @map("password_hash")
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  lastLoginAt    DateTime? @map("last_login_at") @db.Timestamptz

  settings       UserSettings?
  collaborations CaseCollaborator[]
  edges          UserEdge[]

  @@index([email])
  @@map("users")
}

/// User settings
model UserSettings {
  userId              String  @id @map("user_id") @db.Uuid
  theme               String  @default("light")
  language            String  @default("pt-BR")
  defaultZoom         Int     @default(1) @map("default_zoom")
  showNavigator       Boolean @default(true) @map("show_navigator")
  showScale           Boolean @default(true) @map("show_scale")
  autoRotate          Boolean @default(false) @map("auto_rotate")
  annotationColor     String  @default("#FF0000") @map("annotation_color")
  notificationsEmail  Boolean @default(true) @map("notifications_email")
  notificationsBrowser Boolean @default(true) @map("notifications_browser")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

/// N:N link between users and edge agents they can access.
/// When userId is null, the row is a pending invitation (matched by email on first login).
model UserEdge {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String?  @map("user_id") @db.Uuid
  email     String
  edgeId    String   @map("edge_id")
  isPrimary Boolean  @default(false) @map("is_primary")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([email, edgeId])
  @@index([userId])
  @@index([email])
  @@index([edgeId])
  @@map("user_edges")
}

/// Read model for annotations (ROIs)
model AnnotationRead {
  id          Int      @id @default(autoincrement())
  slideId     String   @map("slide_id")
  name        String
  color       String   @default("#FF0000")
  type        String   @default("rectangle") // rectangle, arrow, freehand
  coordinates Json     // { x, y, width, height, points? }
  status      String   @default("open") // open, pending_review, resolved
  priority    String   @default("normal") // low, normal, high, urgent
  createdBy   String?  @map("created_by") @db.Uuid
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  messages    MessageRead[]

  @@index([slideId])
  @@index([createdBy])
  @@index([status])
  @@map("annotations_read")
}

/// Viewer audit log for PathoWeb integration tracking
model ViewerAuditLog {
  id             String   @id @default(uuid()) @db.Uuid
  slideId        String   @map("slide_id")
  externalCaseId String?  @map("external_case_id")
  action         String   // viewer_opened, magic_link_created, case_attached
  ipAddress      String?  @map("ip_address")
  userAgent      String?  @map("user_agent")
  metadata       Json?
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([slideId])
  @@index([externalCaseId])
  @@index([createdAt])
  @@map("viewer_audit_log")
}

/// Extension devices paired via short-code flow
model ExtensionDevice {
  id         String    @id @default(uuid()) @db.Uuid
  clinicId   String    @map("clinic_id") @db.Uuid
  name       String
  tokenHash  String    @map("token_hash")
  createdAt  DateTime  @default(now()) @map("created_at") @db.Timestamptz
  revokedAt  DateTime? @map("revoked_at") @db.Timestamptz
  lastSeenAt DateTime? @map("last_seen_at") @db.Timestamptz

  @@index([clinicId])
  @@index([tokenHash])
  @@map("extension_devices")
}

/// Short-lived pairing codes for device registration
model PairingCode {
  id        String    @id @default(uuid()) @db.Uuid
  code      String    @unique
  clinicId  String    @map("clinic_id") @db.Uuid
  expiresAt DateTime  @map("expires_at") @db.Timestamptz
  usedAt    DateTime? @map("used_at") @db.Timestamptz
  deviceId  String?   @map("device_id") @db.Uuid

  @@index([code])
  @@map("pairing_codes")
}

/// Messages in annotation discussion threads
model MessageRead {
  id           String   @id @default(uuid()) @db.Uuid
  annotationId Int      @map("annotation_id")
  authorId     String   @map("author_id") @db.Uuid
  content      String
  type         String   @default("text") // text, system, ai_analysis, ai_suggestion
  aiConfidence Float?   @map("ai_confidence")
  aiFindings   Json?    @map("ai_findings") // Array of { label, value, severity? }
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz

  annotation   AnnotationRead @relation(fields: [annotationId], references: [id], onDelete: Cascade)

  @@index([annotationId])
  @@index([authorId])
  @@index([createdAt])
  @@map("messages_read")
}
